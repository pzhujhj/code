1、__attribute__((packed)) 作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐

2、typedef struct _test_two {
	int type;
	int len;
	char value[0];
}__attribute__((packed)) TEST_TWO;
最后一个成员为可变长的数组，对于TLV（Type-Length-Value）形式的结构，或者其他需要变长度的结构体，用这种方式定义最好。
使用起来非常方便，创建时，malloc一段结构体大小加上可变长数据长度的空间给它，可变长部分可按数组的方式访问，释放时，直接把整个结构体free掉就可以了
ttwo = (TEST_TWO *)malloc(sizeof(TEST_TWO) + size);
char value[0]中的value并不是指针，是一个偏移量，这个偏移量指向的是type、len后面紧接着的空间，代表了该结构体后面数据的起始地址，所以它其实并不占用任何空间
在结构体中，我们定义了0长度的数组，按理对value进行赋值时是属于越界访问，但是我们把结构体后面的size个长度的空间也一起申请了，所以该访问是合法的

3、这样设计的好处：
结构体最后使用0或1的长度数组的原因，主要是为了方便的管理内存缓冲区，如果你直接使用指针而不使用数组，那么，你在分配内存缓冲区时，就必须分配结构体一次，
然后再分配结构体内的指针一次，（而此时分配的内存已经与结构体的内存不连续了，所以要分别管理即申请和释放）而如果使用数组，那么只需要一次就可以全部分配出来，
反过来，释放时也是一样，使用数组，一次释放，使用指针，得先释放结构体内的指针，再释放结构体。还不能颠倒次序

4、结构体中最后一个数组长度为零，有些编译器会报错无法编译，可以改成char data[1],或则char data[]。 总之，结构体最后使用0或1的长度数组的原因，
主要是为了方便的管理内存缓冲区，当使用指针时候（使用方法一时），不能分配一段连续的的内存，会增加内存的碎片化